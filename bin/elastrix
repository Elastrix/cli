#!/bin/bash

## @author Michael Labieniec <ml@elastrix.io>
## @brief Elastrix cli tools
## @copyright GPLv3
## @version 1.0

## Check for root
if [[ $EUID -ne 0 ]]; then
   echo
   echo -e "  \e[31m\e[1m[!] Elastrix cli must be run with sudo i.e. sudo elastrix\e[0m" 1>&2
   echo
   exit 1
fi

## source the config
if [ -f "$HOME/.elx" ]; then
	. "$HOME/.elx"
fi

##
# main program init and system variables
##

## Set the script path
ELX_SCRIPT_PATH="`dirname \"$0\"`"
ELX_SCRIPT_PATH="`( cd \"$ELX_SCRIPT_PATH\" && pwd )`"
if [ -z "$ELX_SCRIPT_PATH" ]
then
  echo "  \e[31m\e[1m[!] Permission denied, are you running with sudo?\e[0m"
  exit 1
fi

## NGINX Settings
NGINX_CONF_FILE="$(awk -F= -v RS=' ' '/conf-path/ {print $2}' <<< $(nginx -V 2>&1))"
NGINX_CONF_DIR="${NGINX_CONF_FILE%/*}"
NGINX_SITES_AVAILABLE="$NGINX_CONF_DIR/sites-available"
NGINX_SITES_ENABLED="$NGINX_CONF_DIR/sites-enabled"
SELECTED_SITE="$2"

##
# private variables
##

## Check what platform we are on and set the script name
platform="`uname -s`/`uname -m`"
me=$(basename "$0")

## describe the supported apps
apps[0]='Ghost on NGINX'
apps[1]='WordPress on NGINX'
apps[2]='WordPress on Apache'
apps[3]='Elastrix Media Server'
apps[4]='LAMP with Webmin'
apps[5]='Parse Server'
apps[6]='Quit'

## Displays a warning if ec2-metadata program is not found
warnEc2MetadataNotFound() {
	warn "ec2-metadata not found, are you running on EC2?"
	info "Elastrix supports EC2 instances on Debian based Linux platforms."
}

warn() {
	echo -e "  \e[31m\e[1m[!] $1\e[0m"
}

info() {
	echo -e "  \e[1m[i] $1\e[0m" 
}

prompt() {
	read -p "  \e[1m[?] $1 : \e[0m" $2
}

## initialize
init() {
	user=$(whoami)
	## check if we have access to ec2-metadata
	if hash ec2-metadata 2>/dev/null; then
		url=$(ec2metadata --public-hostname)
		ip=$(ec2metadata --public-ipv4)
	else
		## determine public ip and hostname
		if hash dig 2>/dev/null; then
			
			echo -e "  [i] Detecting DNS..."
			ip=$( curl http://ip4.me 2>/dev/null | sed -e 's#<[^>]*>##g' | grep '^[0-9]' )
			domain=$( dig +short -x $ip)
			
			if [[ -n $domain ]]; then
				url=${domain::-1}
			elif [[ user="azureuser" ]]; then
				azurehost=$(hostname)
				url="${azurehost}.cloudapp.net"
			else
				warn "Unable to detect your external host name."
				url="domain.com"
			fi	
		else
			warn "Unable to detect your external host settings."
			ip="0.0.0.0"
			url=$(hostname)
		fi
	fi
	info "Detected Public Host:          \e[4m$url"
	info "Detected Public IP Address:    \e[4m$ip"
}

##
# main functions and utilities
##

## Display Elastrix header
header() {
	echo -e '     __ _           _        _        '
	echo -e '    /__\ | __ _ ___| |_ _ __(_)_  __  '
	echo -e '   /_\ | |/ _` / __| __| `__| \ \/ /  '
	echo -e '  //__ | | (_| \__ \ |_| |  | |>  <   '
	echo -e '  \__/ |_|\__,_|___/\__|_|  |_/_/\_\ '"v${ELX_VERSION}"
	echo 
	echo
	#if [[ $platform ]]; then
	#	echo -e "   ${platform} detected"
	#fi
	#echo
}

## Determine which setup to run, otherwise present menu
setup() {
	if [ -e "/var/www/html/wordpress" ]; then		
		if hash nginx 2>/dev/null; then
			setupWordpressNginx
		elif [ -f "/etc/init.d/apache2" ]; then
			setupWordpressApache
		else
			menuSetup
		fi
	elif [ -f "/etc/init/ghost.conf" ]; then
		if hash nginx 2>/dev/null; then
			setupGhostNginx
		else
			menuSetup
		fi
	elif [ -f "/etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini" ]; then
		setupElastrixMediaServer
	elif [ -f "/etc/init.d/apache2" ] && [ -e "/var/www/html" ]; then
		setupLAMP
	elif [ -f "/etc/init/parse.conf" ]; then
		setupParse
	else
		menuSetup
	fi
}

## Try and execute a program, warn and quit if not found
execute() {
	if hash $1 2>/dev/null; then
		exec $1
	else
		warnExecNotFound $1
		exit 1
	fi
}



## ask whic setup program to run
menuSetup() {
	warn "Your app could not be detected. "
	PS3='Please choose your app: '
	select opt in "${apps[@]}"
	do
	    case $opt in
	        "Ghost on NGINX")
	            setupGhostNginx
	            ;;
	        "WordPress on Apache")
	            setupWordpressApache
	            ;;
	        "WordPress on NGINX")
	            setupWordpressNginx
	            ;;
	        "Elastrix Media Server")
				setupElastrixMediaServer
				;;
			"LAMP with Webmin")
				setupLAMP
				;;
	        "Quit")
				warnElastrixSetupNotFound
	            break
	            ;;
	        *) echo invalid option;;
	    esac
	done
}

## Check what platform we are running on
checkPlatform() {
	case $platform in
	  (Darwin/i386|Darwin/x86_64|Linux/i386|Linux/x86_64)
	    true
	    ;;
	  (Linux/i[456]86)
	    platform=Linux/i386
	    ;;
	  (Linux/armv[67]l)
	    platform=Linux/arm
	    ;;
	  (*)
	    warn "Unsupported platform: $platform."
	    exit 1
	    ;;
	esac
}

## Display a warning when an elastrix setup program is not found
warnElastrixSetupNotFound() {
	warn "Elastrix setup not found."
	info "Please try re-installing Elastrix with the following commands: "
	echo 
	echo -e "    \e[0mcurl -L http://elastrix.io/start | sudo bash"
	echo -e "    \e[0msudo apt-get install elastrix"
	echo
}

## display a warning when an executable is not found
warnExecNotFound() {
	warn "$1 not found."
	info "Please try re-installing Elastrix."
	echo 
	echo -e "    \e[0mcurl -L http://elastrix.io/start | sudo bash"
	echo -e "    \e[0msudo apt-get install elastrix"
	echo
}

if [[ $ELX_DEV ]]
then
	libs=$(ls $ELX_SCRIPT_PATH/lib)
	for l in $libs; do
		. $ELX_SCRIPT_PATH/lib/$l
	done

	modules=$(ls $ELX_SCRIPT_PATH/modules)
	for f in $modules; do
		. $ELX_SCRIPT_PATH/modules/$f
	done
	. $ELX_SCRIPT_PATH/main.sh
fi

##
# modules
##

##
# module
##

## @details
## @par URL
## https://github.com/Anvil/bash-argsparse @n
#
## @par Purpose
#
## To replace the option-parsing and usage-describing functions
## commonly rewritten in all scripts.
##
## @note
## This library is implemented for bash version 4. Prior versions of
## bash will fail at interpreting that code.
## @note
## The extglob shell option will be enabled and posix mode will be
## disabled when loading the library. Changing those settings
## afterwards will make the library execution fail.
#
## @par Usage
## Use the argsparse_use_option() function to declare your options with
## their single letter counterparts, along with their description.
##
## @par
## The argsparse_use_option() syntax is:
##
## @code
##     argsparse_use_option "optstring" "option description string" \
##     [ "property" ... ] [ "optional default value" ]
## @endcode
##
##
## @par
## An "optstring" is of the form "som=estring:". This would declare a
## long option named somestring. The ending ":" is optional and, if
## present, means the long option expects a value on the command
## line. The "=" char is also optional and means the immediatly
## following letter is the short single-letter equivalent option of
## --something.
##
## @par
## The "something" string must only contains ASCII
## letters/numbers/dash/underscore characters.
##
## @note
## What is referred later as "option" or "option name" (or even "long
## option name") is the optstring without the ':' and '=' characters.
##
###
##
## @par Options may have properties.
##
## Properties are set either at option declarations through the
## argsparse_use_option() function, or using the
## argsparse_set_option_property() function
##
## The currently supported properties are:
##
## @li "hidden" @n
## 	 An hidden option will not be shown in usage.
##
## @li "mandatory" @n
## 	 An option marked as mandatory is required on the command line. If
##   a mandatory option is omited by the user, usage() will be
##   triggered by argsparse_parse_options().
##
## @li "value" @n
##   On the command line, the option will require a value.
## 	 Same effect if you end your optstring with a ':' char.
##
## @li "default:<defaultvalue>" @n
## 	 The default value for the option.
##
## @li "short:<char>" @n
##   The short single-letter equivalent of the option.
##
## @li "type:<typename>" @n
##   Give a type to the option value. User input value will be checked
## 	 against built-in type verifications _or_ the
## 	 "check_type_<typename>" function. You cannot override a built-in
## 	 type. Built-in types are:
##
## @code
##   file directory pipe terminal socket link char unsignedint uint
##   integer int hexa ipv4 ipv6 ip hostname host portnumber port
##   username group date
## @endcode
##
## @li "exclude:<option> <option>" @n
##   The exclude property value is a space-separated list of other
##   options. User wont be able to provided two mutually exclusive
##   options on the command line. @n
##
##   e.g: if you set exclude property for the --foo option this way:
##   @code argsparse_set_option_property "exclude:opt1 opt2" foo @endcode
##   Then --opt1 and --foo are not allowed on the same command line
##   invokation. And same goes for --opt2 and --foo.
##   This foo exclude property setting wouldnt make --opt1 and --opt2,
##   mutually exclusive though.
##
## @li "alias:<option> <option>" @n
##   This property allows an option to set multiple other without-value
##   options instead. Recursive aliases are permitted but no loop
##   detection is made, so be careful. @n
##   e.g: if you declare an option 'opt' like this:
##   @code argsparse_use_option opt "my description" "alias:opt1 opt2" @endcode
##   Then if the user is doing --opt on the command line, it will be as
##   if he would have done --opt1 --opt2
##
## @li cumulative @n
##   Implies 'value'.
##   Everytime a cumulative option "optionname" is passed on the
##   command line, the value is stored at the end of an array named
##   "cumulated_values_<optionname>". @n
##
##   e.g: for a script with an opt1 option declared this way:
##   @code argsparse_use_option opt1 "some description" cumulative @endcode
##   and invoked with:
##   @code --opt1 value1 --opt1 value2 @endcode
##   after argsparse_parse_options(), "${cumulated_values_opt1[0]}" will
##   expand to value1, and ${cumulated_values_opt1[1]} will expand to
##   value2.
##
## @li cumulativeset @n
##   Exactly like cumulative, except only uniq values are kept. @n
##
##   e.g: for a script with an opt1 option declared this way:
##   @code argsparse_use_option opt1 "some description" cumulativeset @endcode
##   and invoked with:
##   @code --opt1 value1 --opt1 value2 --opt1 value1 @endcode
##   after argsparse_parse_options(), "${cumulated_values_opt1[0]}" will
##   expand to value1, and "${cumulated_values_opt1[1]}" will expand to
##   value2. There would be no "${cumulated_values_opt1[2]}" value.
##
## @li "require:<option> <option>" @n
##   Creates a dependency between options. if you declare an option with:
##   @code
##   argsparse_use_option opt1 "something" require:"opt2 opt3"
##   @endcode
##   argsparse_parse_options() would return with an error if "--opt1"
##   is given on the commande line without "--opt2" or without "--opt3".
##
## @par
## You can test if an option has a property using the
## argsparse_has_option_property() function.
## @code argsparse_has_option_property <option> <property> @endcode
##
#
## @par Parsing positionnal parameters
## After the options are declared, invoke the function
## argsparse_parse_options() with the all script parameters. This will
## define:
##
## @li program_params, an array, containing all non-option parameters.
##
## @li program_options, an associative array. For each record of the
##   array:
##   - The key is the long option name.
##   - And about values:
##     - If option doesn't expect a value on the command line, the
##       value represents how many times the option has been
##       found on the command line
##
##     - If option does require a value, the array record value is the
##       value of the last occurence of the option found on the command
##       line.
##     .
##   - If option is cumulative (or cumulativeset), the array record
##     value is the number of values passed by the user.
##   .
## After argsparse_parse_options() invokation, you can check if an
## option have was on the command line (or not) using the
## argsparse_is_option_set() function. @n
##
## e.g:
## @code argsparse_is_option_set "long-option-name" @endcode
##
###
## @par The "usage()" function
## If a 'usage' function is defined, and shall
## argsparse_parse_options() return with non-zero status, 'usage' will
## be automatically called.
##
## @note
## This library automatically defines a default 'usage' function,
## which may be removed or overridden by the sourcing program
## afterwards.
#
##
## @par Value setting internal logic
## During option parsing, for every option of the form '--optionname'
## expecting a value:
##
## @li If there exists an array named "option_<optionname>_values" and
##   the user-given value doesn't belong to that array, then the
##   argsparse_parse_options() function immediately returns with
##   non-zero status, triggering 'usage'.
##
## @li If the "option_<optionname>_values" array does not exist, but if
##   the option has a type property field, then the value format will
##   be checked agaisnt that type.
##
## @li If a function named "check_value_of_<optionname>" has been
##   defined, it will be called with the user-given value as its first
##   positionnal parameter. If check_value_of_<optionname> returns
##   with non-zero status, then parse_option immediately returns with
##   non-zero status, triggering the 'usage' function.
##
## @par
## Also, still during option parsing and for @b every option of the form
## "--optionname":
##
## @li After value-checking, if a function named
##   "set_option_<optionname>" exists, then, instead of directly
##   modifying the "program_options" associative array, this function
##   is automatically called with 'optionname' as its first
##   positionnal parameter, and, if 'optionname' expected a value, the
##   value is given as the function second positionnal parameter.
##
## @par About functions return values...
##
## All the functions will return with an error (usually a return code
## of 1) if called with a wrong number of parameters, and return with
## 0 if everything went fine.
#
## @defgroup ArgsparseUsage Calling program usage description message.
## @defgroup ArgsparseOptionSetter Setting options values.
## @defgroup ArgsparseProperty Options properties handling.
## @defgroup ArgsparseParameter Non-optional positionnal parameters.

# We're not compatible with older bash versions.
if [[ "$BASH_VERSINFO" -lt 4 ]]
then
	printf >&2 "This requires bash >= 4 to run.\n"
	return 1 2>/dev/null
	exit 1
fi

if ! command -v getopt >/dev/null 2>&1
then
	printf >&2 "Cannot find the getopt command.\n"
	return 1 2>/dev/null
	exit 1
fi

if declare -rp ARGSPARSE_VERSION >/dev/null 2>&1
then
	# argsparse is already loaded.
	return 0 2>/dev/null
fi

## @var ARGSPARSE_VERSION
## @brief argsparse version number
## @showinitializer
declare -r ARGSPARSE_VERSION=1.7

# Enable required features
shopt -s extglob
set +o posix

# This is an associative array. It should contains records of the form
# "something" -> "Some usage description string".
# The "something" string is referred as the "option name" later in
# source code and comments.
## @var AssociativeArray __argsparse_options_descriptions
## @private
## @brief Internal use only.
declare -A __argsparse_options_descriptions=()

## @brief The name of the program currently using argsparse.
## @details Automatically set by argsparse at load time, it contains
## the basename (path-less but with extension, if any) of the main
## script. Used internally to print error messages and by
## usage-related functions, but can be used by the loading script.
## @hideinitializer
declare -r argsparse_pgm=${0##*/}

## @brief Internal use only.
## @details The default minimum parameters requirement for command line.
## @ingroup ArgsparseParameter
declare -i __argsparse_minimum_parameters=0

## @brief Internal use only.
## @details An associative array where options default values are
## stored as soon as the 'default:' property is set.
## @ingroup ArgsparseProperty
declare -A __argsparse_options_default_values=()

## @fn argsparse_minimum_parameters()
## @brief Set the minimum number of non-option parameters expected on
## the command line.
## @param unsigned_int a positive number.
## @retval 0 if there is an unsigned integer is provided and is the
## single parameter of this function.
## @retval 1 in other cases.
## @ingroup ArgsparseParameter
argsparse_minimum_parameters() {
	[[ $# -eq 1 ]] || return 1
	local min=$1
	[[ "$min" = +([0-9]) ]] || return 1
	__argsparse_minimum_parameters=$min
}

## @brief Internal use only.
## @details The default maximum parameters requirement for command
## line. "Should be enough for everyone".
## @ingroup ArgsparseParameter
declare -i __argsparse_maximum_parameters=1000000

## @fn argsparse_maximum_parameters()
## @brief Set the maximum number of non-option parameters expected on
## the command line.
## @param unsigned_int a positive number.
## @retval 0 if there is an unsigned integer is provided and is the
## single parameter of this function.
## @retval 1 in other cases.
## @ingroup ArgsparseParameter
argsparse_maximum_parameters() {
	[[ $# -eq 1 ]] || return 1
	local max=$1
	[[ "$max" = +([0-9]) ]] || return 1
	__argsparse_maximum_parameters=$max
}


# 2 generic functions

# @fn __argsparse_index_of()
# @param value a value
# @param values... array values
# @brief Tells if a value is found in a set of other values.
# @details Look for @a value and print its position in the @a values
# set. Return false if it can not be found.
# @retval 0 if @a value is amongst @a values
# @retval 1 if @a value is not found.
__argsparse_index_of() {
	[[ $# -ge 2 ]] || return 1
	local key=$1 ; shift
	local index=0
	local elem
	for elem in "$@"
	do
		if [[ "$key" = "$elem" ]]
		then
			printf %s "$index"
			return 0
		fi
		: $((index++))
	done
	return 1
}

# @fn __argsparse_join_array()
# @param c a single char
# @param strings... strings to join
# @brief join multiple strings by a char.
# @details Like the 'str.join' string method in python, join multiple
# strings by a char. Only work with a single char, though.
# @retval 1 if first parameter is invalid.
# @retval 0 else.
__argsparse_join_array() {
	[[ $# -ge 1 && $1 = ? ]] || return 1
	local IFS="$1$IFS"
	shift
	printf %s "$*"
}

## @fn argsparse_option_to_identifier()
## @brief Give the identifier name associated to an option.
## @details Transforms and prints an option name into a string which
## suitable to be part of a function or a variable name.
## @param option an option name.
argsparse_option_to_identifier() {
	[[ $# -eq 1 ]] || return 1
	local option=$1
	printf %s "${option//-/_}"
}

# Following functions define the default option-setting hook and its
# with/without value counter-parts. They can be referered in external
# source code, though they should only be in user-defined
# option-setting hooks.

# All user-defined option-setting hook should be defined like
# argsparse_set_option

## @fn argsparse_set_option_without_value()
## @brief The option-setting hook for options not accepting values.
## @param option an option name.
## @retval 0
## @ingroup ArgsparseOptionSetter
argsparse_set_option_without_value() {
	[[ $# -eq 1 ]] || return 1
	local option=$1
	: $((program_options["$option"]++))
}

## @fn argsparse_set_option_with_value()
## @brief "value" property specific option-setting hook.
## @param option an option name.
## @param value the value put on command line for given option.
## @ingroup ArgsparseOptionSetter
argsparse_set_option_with_value() {
	[[ $# -eq 2 ]] || return 1
	local option=$1
	local value=$2
	program_options["$option"]=$value
}

## @fn argsparse_get_cumulative_array_name()
## @param option an option name.
## @brief Print the name of the array used for "cumulative" and
## "cumulativeset" options.
## @details For "option-name" usually prints
## "cumulated_values_option_name".
argsparse_get_cumulative_array_name() {
	[[ $# -eq 1 ]] || return 1
	local option=$1
	local ident=$(argsparse_option_to_identifier "$option")
	printf "cumulated_values_%s" "$ident"
}

## @fn argsparse_set_cumulative_option()
## @brief "cumulative" property specific option-setting hook.
## @details Default action to take for cumulative options. Store @a
## value into an array whose name is generated using
## argsparse_get_cumulative_array_name().
## @param option an option name.
## @param value the value put on command line for given option.
## @ingroup ArgsparseOptionSetter
argsparse_set_cumulative_option() {
	[[ $# -eq 2 ]] || return 1
	local option=$1
	local value=$2
	local array="$(argsparse_get_cumulative_array_name "$option")"
	local size temp="$array[@]"
	local -a copy
	if __argsparse_has_array_item "$array" 0
	then
		copy=( "${!temp}" )
		size=${#copy[@]}
	else
		size=0
	fi
	printf -v "$array[$size]" %s "$value"
	argsparse_set_option_without_value "$option"
}

## @fn argsparse_set_cumulativeset_option()
## @param option an option name.
## @param value a new value for the option.
## @brief "cumulativeset" property specific option-setting hook.
## @details Default action to take for cumulativeset options. Act
## exactly like argsparse_set_cumulative_option() except that values
## are not duplicated in the cumulated values array.
## @ingroup ArgsparseOptionSetter
argsparse_set_cumulativeset_option() {
	[[ $# -eq 2 ]] || return 1
	local option=$1
	local value=$2
	local array_name="$(argsparse_get_cumulative_array_name "$option")"
	local array="$array_name[@]"
	if ! __argsparse_has_array_item "$array_name" || \
		   ! __argsparse_index_of "$value" "${!array}" >/dev/null
	then
		# The value is not already in the array, so add it.
		argsparse_set_cumulative_option "$option" "$value"
	fi
}

## @fn argsparse_set_alias()
## @param option an option name.
## @brief "alias" property specific option-setting hook.
## @details When an option is an alias for other option(s), then set
## the aliases options.
## @ingroup ArgsparseOptionSetter
argsparse_set_alias() {
	# This option will set all options aliased by another.
	[[ $# -eq 1 ]] || return 1
	local option=$1
	local aliases
	if ! aliases="$(argsparse_has_option_property "$option" alias)"
	then
		return 1
	fi
	while [[ "$aliases" =~ ^\ *([^\ ]+)(\ (.+))?\ *$ ]]
	do
		# At this point, BASH_REMATCH[1] is the first alias, and
		# BASH_REMATCH[3] is the maybe-empty list of other aliases.
		# __argsparse_set_option will alter BASH_REMATCH, so modify
		# aliases first.
		aliases=${BASH_REMATCH[3]}
		__argsparse_set_option "${BASH_REMATCH[1]}"
	done
}

## @fn argsparse_set_option()
## @brief Default option-setting hook.
## @param option The option being set.
## @param value the value of the option (optional).
## @details This function will be called by argsparse_parse_options()
## whenever an option is being and no custom setting hook is define
## for this option. Depending of the properties of the option a more
## specific setting hook will be called.
## @ingroup ArgsparseOptionSetter
argsparse_set_option() {
	[[ $# -eq 2 || $# -eq 1 ]] || return 1
	local option=$1
	if [[ $# -eq 2 ]]
	then
		local value=$2
	fi
	local property
	local -A setters=(
		[cumulative]=argsparse_set_cumulative_option
		[cumulativeset]=argsparse_set_cumulativeset_option
		[value]=argsparse_set_option_with_value
	)

	if ! argsparse_set_alias "$option"
	then
		# We dont use ${!setters[@]} here, because order matters.
		for property in cumulative cumulativeset value
		do
			if argsparse_has_option_property "$option" "$property"
			then
				"${setters[$property]}" "$option" "$value"
				return
			fi
		done
		argsparse_set_option_without_value "$option"
	fi
}


# The usage-related functions.

__argsparse_usage_short_line_management() {
	[[ $# -eq 1 ]] || return 1
	local next_token=$1
	local max_length=78
	local bigger_line
	bigger_line="$current_line $next_token"
	if [[ "${#bigger_line}" -gt "$max_length" ]]
	then
		printf -- '%s \\\n' "$current_line"
		printf -v current_line "\t%s" "$next_token"
	else
		current_line=$bigger_line
	fi
}

## @fn argsparse_usage_short()
## @brief Print a short description of the program syntax.
## @details Generate and print the "short" description of the program
## usage.
## @ingroup ArgsparseUsage
argsparse_usage_short() {
	local option values current_line current_option param
	local max_length=78
	current_line=$argsparse_pgm
	for option in "${!__argsparse_options_descriptions[@]}"
	do
		if argsparse_has_option_property "$option" hidden
		then
			continue
		fi
		current_option="--$option"
		if argsparse_has_option_property "$option" value
		then
			if values=$(__argsparse_values_array_identifier "$option")
			then
				current_option="$current_option <$(
					__argsparse_join_array '|' "${!values}")>"
			else
				current_option="$current_option ${option^^}"
			fi
		fi
		if ! argsparse_has_option_property "$option" mandatory
		then
			current_option="[ $current_option ]"
		fi
		__argsparse_usage_short_line_management "$current_option"
	done
	if __argsparse_has_array_item __argsparse_parameters_description
	then
	   for param in "${__argsparse_parameters_description[@]}"
	   do
		   __argsparse_usage_short_line_management "$param"
	   done
	fi
	printf -- "%s\n" "$current_line"
}

## @var Array __argsparse_parameters_description
## @private
## @brief Internal use only.
## @ingroup ArgsparseUsage
# @details Used by argsparse_describe_parameters() to store
# non-option positionnal parameters short descriptions and by
# argsparse_usage_short() to print them to end-users.
declare -a __argsparse_parameters_description

## @fn argsparse_describe_parameters()
## @brief Describe non-option positionnal parameters.
## @details 
## This function has currently 2 purposes:
## @li enhance the "short" usage program description (see
## argsparse_usage_short())
## @li compute the minimum and maximum numbers of non-option
## positionnal parameters and will overwrite previous settings using
## argsparse_minimum_parameters() and argsparse_maximum_parameters().
##
## @param param... a list of label describing positionnal
## parameters. These labels can have special forms such as:
##   @li "label?" a single optional non-repeatable parameter
##   @li "label+" a non-empty list of parameters
##   @li "label*" a potentially-empty list of parameters
##   @li "label" a single non-optional non-repeatable parameter
## @retval 0
argsparse_describe_parameters() {
	[[ $# -eq 0 ]] && return
	local param last name
	local -i min=0 max=0
	__argsparse_parameters_description=( "[--]" )
	for param in "$@"
	do
		name=${param%?}
		last=${param#$name}
		case "$last" in
			'?')
				: maximum param $((++max))
				__argsparse_parameters_description+=( "[ $name ]" )
				;;
			'*')
				max=1000000
				__argsparse_parameters_description+=( "[ $name ... ]" )
				;;
			+)
				max=1000000
				: minimum param $((++min))
				__argsparse_parameters_description+=( "$name [ $name ... ]" )
				;;
			*)
				: maximum param $((++max))
				: minimum param $((++min))
				__argsparse_parameters_description+=( "$param" )
		esac
	done
	argsparse_minimum_parameters "$min"
	argsparse_maximum_parameters "$max"
}

## @fn argsparse_usage_long()
## @brief Fully describe the program syntax and options to the end-user.
## @details This function generates and prints the "long" description
## of the program usage. Print all options along with their
## descriptions provided to argsparse_use_option().
## @ingroup ArgsparseUsage
argsparse_usage_long() {
	local long short sep format array property propstring
	local q=\' bol='\t\t  '
	local -A long_to_short=()
	local -a values
	# Reverse the __argsparse_short_options array.
	for short in "${!__argsparse_short_options[@]}"
	do
		long=${__argsparse_short_options["$short"]}
		long_to_short["$long"]=$short
	done
	for long in "${!__argsparse_options_descriptions[@]}"
	do
		if argsparse_has_option_property "$long" hidden
		then
			continue
		fi
		# Pretty printer issue here. If the long option length is
		# greater than 8, we just use next line to print the option
		# description.
		if [[ "${#long}" -le 9 ]]
		then
			sep=' '
		else
			sep="\n$bol"
		fi
		# Define format according to the presence of the short option.
		if __argsparse_has_array_item long_to_short "$long"
		then
			short="${long_to_short[$long]}"
			format=" -%s | %- 11s$sep%s\n"
		else
			short=""
			format=" %s     %- 11s$sep%s\n"
		fi
		printf -- "$format" "$short" "--$long" \
			"${__argsparse_options_descriptions["$long"]}"
		if argsparse_has_option_property "$long" cumulative || \
			argsparse_has_option_property "$long" cumulativeset
		then
			printf "${bol}Can be repeated.\n"
		fi
		if argsparse_has_option_property "$long" value
		then
			if array=$(__argsparse_values_array_identifier "$long")
			then
				values=( "${!array}" )
				values=( "${values[@]/%/$q}" )
				values=( "${values[@]/#/$q}" )
				printf "${bol}Acceptable values: %s\n" \
					"$(__argsparse_join_array " " "${values[@]}")"
			fi
			if __argsparse_index_of "$long" \
				"${!__argsparse_options_default_values[@]}" >/dev/null
			then
				printf "${bol}Default: %s.\n" \
					"${__argsparse_options_default_values[$long]}"
			fi
		fi
		local -A properties=([require]="Requires" [alias]="Same as")
		for property in "${!properties[@]}"
		do
			if propstring=$(argsparse_has_option_property "$long" "$property")
			then
				read -a values <<<"$propstring"
				values=( "${values[@]/#/--}" )
				printf "${bol}%s: %s\n" \
					"${properties[$property]}" "${values[*]}"
			fi
		done
	done
}

## @var String argsparse_usage_description
## @brief Usage description additionnal string.
## @details The content of this variable will be appended to the
## argsparse_usage() output.
## @ingroup ArgsparseUsage
declare argsparse_usage_description

## @fn argsparse_usage()
## @brief A generic help message generated from the options and their
## descriptions.
## @details Will print both a rather-short and a quite long
## description of the program and its options. Just provided to be
## wrapped in your own usage().
## @ingroup ArgsparseUsage
argsparse_usage() {
	# There's still a lot of room for improvement here.
	argsparse_usage_short
	printf "\n"
	# This will print option descriptions.
	argsparse_usage_long
	[[ -n "${argsparse_usage_description:-}" ]] && \
		printf "\n%s\n" "$argsparse_usage_description" || :
}

## @fn usage()
## @brief Default usage function.
## @details The default usage function. By default, it will be called
## by argsparse_parse_options() on error or if --help option provided by
## user on the command line. It can easily be overwritten if it does not
## suits your needs.
## @return This function makes an @b exit with code 1
## @ingroup ArgsparseUsage
usage() {
	argsparse_usage
	exit 1
}

## @fn set_option_help()
## @brief Default trigger for --help option.
## @details Will actually only call usage().
## @return Whatever usage() returns.
## @ingroup ArgsparseUsage
set_option_help() {
	# This is the default hook for the --help option.
	usage
}

## @fn __argsparse_values_array_identifier()
## @private
## @brief Prints the name of the array containing all user-declared
## acceptable values for an option.
## @details from "opt" or "opt-name" string, prints
## "option_opt_values[@]" or "option_opt_name_values[@]", unless array
## is not declared, in which case function will return an error.
## @param option an option name.
## @retval 1 if array has not been declared
## @retval 0 else. Array name will be written to stdout.
__argsparse_values_array_identifier() {
	local option=$1
	local array="option_$(argsparse_option_to_identifier "$option")_values"
	__argsparse_is_array_declared "$array" || return 1
	printf %s "$array[@]"
}

__argsparse_is_array_declared() {
	# @param an array name.
	# @retval 0 if an array has been already declared by the name of
	# the parameter.
	[[ $# -eq 1 ]] || return 1
	local array_name=$1
	[[ "$(declare -p "$array_name" 2>/dev/null)" = \
		"declare -"[aA]" $array_name='("* ]]
}

__argsparse_has_array_item() {
	# @param an array name.
	# @retval 0 if an array has been already declared by the name of
	# the parameter.
	[[ $# = [12] ]] || return 1
	local array_name=$1
	local index=${2:-@}
	local var="$array_name[$index]"
	(
		set +o nounset
		[[ ${!var+set} = set ]]
	)
}

__argsparse_check_requires() {
	# @return the number of missing option detected, but this function
	# actually stops are the first failing *list* of dependencies.
	local option
	local requirestring require count=0
	local -a requires
	for option in "${!program_options[@]}"
	do
		if ! requirestring="$(argsparse_has_option_property "$option" require)"
		then
			# No requirement for this option.
			continue
		fi
		read -a requires <<<"$requirestring"
		for require in "${requires[@]}"
		do
			if ! argsparse_is_option_set "$require"
			then
				printf >&2 "%s: --%s: requires option --%s.\n" \
					"$argsparse_pgm" "$option" "$require"
				: $((count++))
			fi
		done
		[[ "$count" -ne 0 ]] && return "$count"
	done
	return 0
}

__argsparse_check_missing_options() {
	# @retval 0 if all mandatory options have a value in
	# program_options associative array.
	local option count=0
	for option in "${!__argsparse_options_descriptions[@]}"
	do
		argsparse_has_option_property "$option" mandatory || continue
		# If option has been given, just iterate.
		argsparse_is_option_set "$option" && continue
		printf >&2 "%s: --%s: option is mandatory.\n" \
			"$argsparse_pgm" "$option"
		: $((count++))
	done
	[[ "$count" -eq 0 ]]
}

## @fn argsparse_check_option_type()
## @brief Check if a value matches a given type.
## @details Return True if @a value is of type @a type.
## @param type A case-insensitive type name.
## @param value a value to check.
## @retval 0 if the value matches the given type format.
argsparse_check_option_type() {
	[[ $# -eq 2 ]] || return 1
	local option_type=${1,,}
	local value=$2
	local t
	case "$option_type" in
		file|directory|pipe|terminal)
			# [[ wont accept the -$var as an operator.
			[ -"${option_type:0:1}" "$value" ]
			;;
		socket|link)
			t=${option_type:0:1}
			[ -"${t^^}" "$value" ]
			;;
		char)
			[[ "$value" = ? ]]
			;;
		unsignedint|uint)
			[[ "$value" = +([0-9]) ]]
			;;
		integer|int)
			[[ "$value" = ?(-)+([0-9]) ]]
			;;
		hexa)
			[[ "$value" = ?(0x)+([a-fA-F0-9]) ]]
			;;
		ipv4)
			# Regular expression for ipv4 and ipv6 have been found on
			# http://www.d-sites.com/2008/10/09/regex-ipv4-et-ipv6/
			[[ "$value" =~ ^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$ ]]
			;;
		ipv6)
			[[ "$value" =~ ^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b).){3}(b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b))|(([0-9A-Fa-f]{1,4}:){0,5}:((b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b).){3}(b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b))|(::([0-9A-Fa-f]{1,4}:){0,5}((b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b).){3}(b((25[0-5])|(1d{2})|(2[0-4]d)|(d{1,2}))b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$ ]]
			;;
		ip)
			# Generic IP address.
			argsparse_check_option_type ipv4 "$value" || \
				argsparse_check_option_type ipv6 "$value"
			;;
		hostname)
			# check if value resolv as an IPv4 or IPv6 address.
			host -t a "$value" >/dev/null 2>&1 || \
				host -t aaaa "$value" >/dev/null 2>&1
			;;
		host)
			# An hostname or an IP address.
			argsparse_check_option_type hostname "$value" || \
				argsparse_check_option_type ipv4 "$value" || \
				argsparse_check_option_type ipv6 "$value"
			;;
		portnumber)
			argsparse_check_option_type uint "$value" && \
				[[ "$value" -gt 0 && "$value" -le 65536 ]]
			;;
		port)
			# Port number or service.
			argsparse_check_option_type portnumber "$value" || \
				getent services "$value" >/dev/null 2>&1
			;;
		username)
			getent passwd "$value" >/dev/null 2>&1
			;;
		group)
			getent group "$value" >/dev/null 2>&1
			;;
		date)
			date --date "$value"  >/dev/null 2>&1
			;;
		*)
			# Invoke user-defined type-checking function if available.
			if ! declare -f "check_option_type_$option_type" >/dev/null
			then
				printf >&2 \
					"%s: %s: type has no validation function. This is a bug.\n" \
					"$argsparse_pgm" "$option_type"
				return 2
			fi
			"check_option_type_$option_type" "$value"
			;;
	esac
}

## @fn __argsparse_parse_options_valuecheck()
## @private
## @brief Check a value given to an option.
## @details If an enumeration has been defined for the option, check
## against that. If there's no enumeration, but option has a type
## property, then check against the type. In the end, check against
## check_value_of_<option> function, if it's been defined.
## @param option an option name.
## @param value anything.
## @retval 0 if value is correct for given option.
__argsparse_parse_options_valuecheck() {
	[[ $# -eq 2 ]] || return 1
	local option=$1
	local value=$2
	local identifier possible_values option_type
	identifier="$(argsparse_option_to_identifier "$option")"
	if possible_values=$(__argsparse_values_array_identifier "$option")
	then
		__argsparse_index_of "$value" "${!possible_values}" >/dev/null || \
			return 1
	elif option_type=$(argsparse_has_option_property "$option" type)
	then
		argsparse_check_option_type "$option_type" "$value" || return 1
	fi
	if declare -f "check_value_of_$identifier" >/dev/null 2>&1
	then
		"check_value_of_$identifier" "$value" || return 1
	fi
	return 0
}

# Default behaviour is not to accept empty command lines.
__argsparse_allow_no_argument=no

## @fn argsparse_allow_no_argument()
## @brief Allow empty command lines to run.
## @details Change argsparse behaviour for empty command
## lines. Default says "no argument triggers usage".
## @param string if (case-insensitive) "yes", "true" or "1", the value
## is considered as affirmative. Anything else is a negative value.
## @retval 0 unless there's more than one parameter (or none).
argsparse_allow_no_argument() {
	[[ $# -eq 1 ]] || return 1
	local param=$1
	case "${param,,}" in
		yes|true|1)
			__argsparse_allow_no_argument=yes
			;;
		*)
			__argsparse_allow_no_argument=no
			;;
	esac
}

## @fn argsparse_parse_options()
## @brief Parse program options.
## @details This function will make option parsing happen, and if an error
## is detected, the usage() function will be invoked, if it has been
## defined. If it's not defined, the function will return 1.
## Parse options, and return if everything went fine.
## @param parameters... should be the program arguments.
## @retval 0 if the whole option parsing process went fine.
## @retval 1 if an error is encoutered and usage does not perform an exit.
argsparse_parse_options() {
	unset __argsparse_tmp_identifiers || :
	__argsparse_parse_options_no_usage "$@" && return
	# Something went wrong, invoke usage function, if defined.
	declare -f usage >/dev/null 2>&1 && usage
	return 1
}


__argsparse_parse_options_prepare_exclude() {
	# Check for all "exclude" properties, and fill "exclusions"
	# associative array, which should have been declared in
	# __argsparse_parse_options_no_usage.
	local option exclude excludestring
	local -a excludes
	for option in "${!__argsparse_options_descriptions[@]}"
	do
		excludestring=$(argsparse_has_option_property "$option" exclude) || \
			continue
		exclusions["$option"]+="${exclusions["$option"]:+ }$excludestring"
		# Re-split the string. (without involving anything else)
		read -a excludes <<<"$excludestring"
		for exclude in "${excludes[@]}"
		do
			exclusions["$exclude"]+="${exclusions["$exclude"]:+ }$option"
		done
	done
}

__argsparse_parse_options_check_exclusions() {
	# Check if two options presents on the command line are mutually
	# exclusive. Prints the "other" option if it's the case.
	# @param an option
	# @return 0 if the given option has actually excluded by annother
	# already-given option.
	[[ $# -eq 1 ]] || return 1
	local new_option=$1
	local option

	for option in "${!program_options[@]}"
	do
		if [[ "${exclusions["$option"]-}" =~ ^(.* )?"$new_option"( .*)?$ ]]
		then
			printf %s "$option"
			return 0
		fi
	done
	return 1
}

## @fn __argsparse_set_option()
## @private
## @brief Resolv option-specific setter function and invoke it.
## @details Check if a user-defined option setting function
## (set_option_<optionname>) has been defined or if the generic
## argsparse_set_option() function is to be used. Then invoke the that
## function with the option name as first parameter. If a value for
## the option is involved, it is passed as a second parameter.
## @param option an option name.
## @return the setter function return code
## @ingroup ArgsparseOptionSetter
__argsparse_set_option() {
	[[ $# -eq 1 || $# -eq 2 ]] || return 1
	local option=$1
	local set_hook identifier
	[[ $# -ne 2 ]] || local value=$2
	# The "identifier string" matching next_param, suitable for
	# variable or function names.
	identifier="$(argsparse_option_to_identifier "$option")"
	# If user has defined a specific setting hook for given the
	# option, then use it, else use default standard
	# option-setting function.
	if declare -f "set_option_$identifier" >/dev/null 2>&1
	then
		set_hook="set_option_$identifier"
	else
		set_hook=argsparse_set_option
	fi
	# Invoke setting hook, and if it returns some non-zero status,
	# send the user back to usage, if declared, and return with error.
	# The specific $value substitution, here, is to distinguish an
	# empty value from a no-value.
	"$set_hook" "$option" ${value+"$value"}
}

__argsparse_parse_options_no_usage() {
	# This function re-set program_params array values. This function
	# will also modify the program_options associative array.
	# If any error happens, this function will return 1.

	# Be careful, the function is (too) big.

	local long short getopt_temp next_param set_hook option_type
	local next_param_identifier exclude value
	local -a longs_array
	local -A exclusions
	# The getopt parameters.
	local longs shorts option

	# No argument sends back to usage, if defined.
	if [[ $# -eq 0 && "$__argsparse_allow_no_argument" != yes ]]
	then
		return 1
	fi

	# 1. Analyze declared options to create getopt valid arguments.
	for long in "${!__argsparse_options_descriptions[@]}"
	do
		if argsparse_has_option_property "$long" value
		then
			longs_array+=( "$long:" )
		else
			longs_array+=( "$long" )
		fi
	done

	# 2. Create the long options string.
	longs="$(__argsparse_join_array , "${longs_array[@]}")"

	# 3. Create the short option string.
	for short in "${!__argsparse_short_options[@]}"
	do
		if argsparse_has_option_property \
			"${__argsparse_short_options[$short]}" value
		then
			shorts+="$short:"
		else
			shorts+=$short
		fi
	done

	# 4. Invoke getopt and replace arguments.
	if ! getopt_temp=$(getopt -s bash -n "$argsparse_pgm" \
		--longoptions="$longs" "$shorts" "$@")
	then
		# Syntax error on the command implies returning with error.
		return 1
	fi
	eval set -- "$getopt_temp"

	# 5. Prepare exclusions stuff.
	__argsparse_parse_options_prepare_exclude

	# 6. Arguments parsing is really made here.
	while [[ $# -ge 1 ]]
	do
		next_param=$1
		shift
		# The regular exit case.
		if [[ "$next_param" = -- ]]
		then
			# Check how many parameters we have and if it's at least
			# what we expects.
			if [[ $# -lt "$__argsparse_minimum_parameters" ]]
			then
				printf >&2 \
					"%s: not enough parameters (at least %d expected, %d provided)\n" \
					"$argsparse_pgm" "$__argsparse_minimum_parameters" $#
				return 1
			elif [[ $# -gt "$__argsparse_maximum_parameters" ]]
			then
				printf >&2 \
					"%s: too many parameters (maximum allowed is %d, %d provided)\n" \
					"$argsparse_pgm" "$__argsparse_maximum_parameters" $#
				return 1
			fi
			# Save program parameters in array
			program_params=( "$@" )

			# Apply default values here
			for option in "${!__argsparse_options_default_values[@]}"
			do
				if ! argsparse_is_option_set "$option"
				then
					argsparse_set_option "$option" \
						"${__argsparse_options_default_values[$option]}"
				fi
			done

			# If some mandatory option have been omited by the user, then
			# print some error, and invoke usage.
			# Also checks requires chains.
			__argsparse_check_missing_options && __argsparse_check_requires
			return
		fi
		# If a short option was given, then we first convert it to its
		# matching long name.
		if [[ "$next_param" = -[!-] ]]
		then
			next_param=${next_param#-}
			if [[ -z "${__argsparse_short_options[$next_param]}" ]]
			then
				# Short option without equivalent long. According to
				# current implementation, this should be considered as
				# a bug.
				printf >&2 \
					"%s: -%s: option doesnt have any matching long option." \
					"$argsparse_pgm" "$next_param"
				return 1
			fi
			next_param=${__argsparse_short_options[$next_param]}
		else
			# Wasnt a short option. Just strip the leading dash.
			next_param=${next_param#--}
		fi
		if exclude=$(__argsparse_parse_options_check_exclusions "$next_param")
		then
			printf >&2 \
				"%s: %s: option excluded by other option (%s).\n" \
				"$argsparse_pgm" "$next_param" "$exclude"
			return 1
		fi
		# Set option value, if there should be one.
		if argsparse_has_option_property "$next_param" value
		then
			value=$1
			shift
			if ! __argsparse_parse_options_valuecheck "$next_param" "$value"
			then
				printf >&2 "%s: %s: Invalid value for option %s.\n" \
					"$argsparse_pgm" "$value" "$next_param"
				return 1
			fi
		fi
		# Invoke setting hook, and if it returns returns some non-zero
		# status, send the user back to usage, if declared, and return
		# with error.
		# The specific $value substitution, here, is to distinguish an
		# empty value from a no-value.
		if ! __argsparse_set_option "$next_param" ${value+"$value"}
		then
			printf >&2 "%s: %s: Invalid value for %s option.\n" \
				"$argsparse_pgm" "$value" "$next_param"
			return 1
		fi
		unset value
	done
	return 0
}

## @var AssociativeArray program_options
## @brief Options values.
## @details
## After argsparse_parse_options(), it will contain (if no hook is set
## for "optionname")
## @li "optionname" -> "value", if "optionname" accepts a value.
## @li "optionname" -> "how many times the option has been detected on
## the command line", else.
declare -A program_options=()

## @var Array program_params
## @brief Positionnal parameters of the script
## @details
## After argsparse_parse_options(), it will contain all non-option
## parameters. (Typically, everything found after the '--')
declare -a program_params=()

## @var AssociativeArray __argsparse_options_properties
## @private
## @brief Internal use only.
## @ingroup ArgsparseProperty
declare -A __argsparse_options_properties=()

## @fn argsparse_set_option_property()
## @brief Enable a property to a list of options.
## @param property a property name.
## @param option... option names.
## @return non-zero if property is not supported.
## @ingroup ArgsparseProperty
argsparse_set_option_property() {
	[[ $# -ge 2 ]] || return 1
	local property=$1
	shift
	local option p short
	for option in "$@"
	do
		case "$property" in
			cumulative|cumulativeset)
				argsparse_set_option_property value "$option"
				;;&
			type:*|exclude:*|alias:*|require:*)
				if [[ "$property" =~ ^.*:(.+)$ ]]
				then
					# If property has a value, check its format, we
					# dont want any funny chars.
					if [[ "${BASH_REMATCH[1]}" = *[*?!,]* ]]
					then
						printf >&2 "%s: %s: invalid property value.\n" \
							"$argsparse_pgm" "${BASH_REMATCH[1]}"
						return 1
					fi
				fi
				;&
			mandatory|hidden|value|cumulative|cumulativeset)
				# We use the comma as the property character separator
				# in the __argsparse_options_properties array.
				p=${__argsparse_options_properties["$option"]:-}
				__argsparse_options_properties["$option"]="${p:+$p,}$property"
				;;
			short:?)
				short=${property#short:}
				if __argsparse_has_array_item \
					__argsparse_short_options "$short"
				then
					printf >&2 \
						"%s: %s: short option for %s conflicts with already-configured short option for %s.\n" \
						"$argsparse_pgm" "$short" "$option" \
						"${__argsparse_short_options[$short]}"
					return 1
				fi
				__argsparse_short_options["$short"]=$option
				;;
			default:*)
				# The default value
				__argsparse_options_default_values["$option"]=${property#default:}
				;;
			*)
				return 1
				;;
		esac
	done
}

## @fn argsparse_has_option_property()
## @brief Determine if an option has a property.
## @details Return True if property has been set for given option, and
## print the property value, if available.
## @param option an option name.
## @param property a property name.
## @retval 0 if option has given property.
## @ingroup ArgsparseProperty
argsparse_has_option_property() {
	[[ $# -eq 2 ]] || return 1
	local option=$1
	local property=$2
	local p=${__argsparse_options_properties["$option"]:-""}

	if [[ "$p" =~ (^|.+,)"$property"(:([^,]+))?($|,.+) ]]
	then
		printf %s "${BASH_REMATCH[3]}"
	elif [[ $property = default && \
		"${__argsparse_options_default_values[$option]+yes}" = yes ]]
	then
			print %s "${__argsparse_options_default_values[$option]}"
	else
		return 1
	fi
}

# Association short option -> long option.
## @var AssociativeArray __argsparse_short_options
## @private
## @brief Internal use only.
declare -A __argsparse_short_options=()

# @fn __argsparse_optstring_has_short()
# @brief Internal use only.
# @details Prints the short option string suitable for getopt command
# line.
# @param optstring an optstring
# @return non-zero if given optstring doesnt have any short option
# equivalent.
__argsparse_optstring_has_short() {
	[[ $# -eq 1 ]] || return 1
	local optstring=$1
	if [[ "$optstring" =~ .*=(.).* ]]
	then
		printf %c "${BASH_REMATCH[1]}"
		return 0
	fi
	return 1
}


## @var AssociativeArray __argsparse_tmp_identifiers
## @private
## @brief Internal use
declare -A __argsparse_tmp_identifiers=()
# Used to verify declared options do not conflict. Is unset after
# argsparse_parse_options().


# @fn _argsparse_check_declaration_conflict()
# @brief Internal use.
# @details Check if an option conflicts with another and, if it does,
# prints the conflicted option.
# @param option an option name
# @return True if option *does* conflict with a previously declared
# option.
__argsparse_check_declaration_conflict() {
	[[ $# -eq 1 ]] || return 1
	local option=$1
	local identifier=$(argsparse_option_to_identifier "$option")
	local -a identifiers=("${!__argsparse_tmp_identifiers[@]}")
	local conflict
	if __argsparse_has_array_item identifiers && \
		   conflict=$(__argsparse_index_of "$identifier" "${identifiers[@]}")
	then
		printf %s "${__argsparse_tmp_identifiers[${identifiers[$conflict]}]}"
		return 0
	fi
	__argsparse_tmp_identifiers["$identifier"]=$option
	return 1
}

## @fn argsparse_use_option()
## @brief Define a @b new option.
## @param optstring an optstring.
## @param description the option description, for the usage function.
## @param property... an non-ordered list of keywords. Recognized
## property keywords are:
##   @li mandatory: missing option will trigger usage. If a default
##     value is given, the option is considered as if provided on
##     the command line.
##   @li hidden: option wont show in default usage function.
##   @li value: option expects a following value.
##   @li short:c: option has a single-lettered (c) equivalent.
##   @li exclude:"option1 [ option2 ... ]" option is not
##   compatible with other options option1, option2...
##   @li cumulative
##   @li cumulativeset
##   @li type:sometype
##   @li The @b last non-keyword parameter will be considered as the
##     default value for the option. All other parameters and
##     values will be ignored. - might be broken / obsolete and broken
## @retval 0 if no error is encountered.
## @retval 2 if option name is bad (a message will be printed)
## @retval 3 if option name conflicts with another option (a message
## will be printed)
## @retval 4 if a wrong property name is provided. (a message will be
## printed)
argsparse_use_option() {
	[[ $# -ge 2 ]] || return 1
	local optstring=$1
	local description=$2
	shift 2
	local long short conflict
	# configure short option.
	if short=$(__argsparse_optstring_has_short "$optstring")
	then
		set -- "short:$short" "$@"
		optstring=${optstring/=/}
	fi
	# --$optstring expect an argument.
	if [[ "$optstring" = *: ]]
	then
		set -- value "$@"
		long=${optstring%:}
	else
		long=$optstring
	fi

	if [[ "$long" = *[!-0-9a-zA-Z_]* ]]
	then
		printf >&2 "%s: %s: bad option name.\n" "$argsparse_pgm" "$long"
		return 2
	fi

	if conflict=$(__argsparse_check_declaration_conflict "$long")
	then
		printf >&2 "%s: %s: option conflicts with already-declared %s.\n" \
			"$argsparse_pgm" "$long" "$conflict"
		return 3
	fi

	__argsparse_options_descriptions["$long"]=$description

	# Any other parameter to this function should be a property.
	while [[ $# -ne 0 ]]
	do
		if ! argsparse_set_option_property "$1" "$long"
		then
			printf >&2 '%s: %s: unknown property.\n' "$argsparse_pgm" "$1"
			return 4
		fi
		shift
	done
}

## @fn argsparse_option_description()
## @brief Prints to stdout the description of given option.
## @param option an option name.
## @retval 0 if given option has been previously declared.
argsparse_option_description() {
	[[ $# -eq 1 ]] || return 1
	local option=$1
	[[ -n "${__argsparse_options_descriptions[$option]+yes}" ]] && \
		printf %s "${__argsparse_options_descriptions[$option]}"
}

## @fn argsparse_is_option_set()
## @brief Return True if an option has been set on the command line.
## @param option an option name.
## @retval 0 if given option has been set on the command line.
argsparse_is_option_set() {
	[[ $# -eq 1 ]] || return 1
	local option=$1
	[[ -n "${program_options[$option]+yes}" ]]
}


# @private
# @fn __max_length()
# @details Prints the length of the longest argument _or_ 50.
# @brief Internal use.
# @param string... a list of strings
# @return 0
__max_length() {
	local max=50
	shift
	local max_length=0 str
	for str in "$@"
	do
		max_length=$((max_length>${#str}?max_length:${#str}))
	done
	printf %d "$((max_length>max?max:max_length))"
}

## @fn argsparse_report()
## @brief Prints a basic report of all passed options
## @details Kinda useful for a --debug, or a --verbose option,
## this function will print options and their values.
## @param option... A list of option name. If omitted all options
## will be displayed.
## @retval 0
argsparse_report() {
	local option array_name value
	local length=$(__max_length "${!__argsparse_options_descriptions[@]}")
	local -a array options

	if __argsparse_is_array_declared __argsparse_tmp_identifiers
	then
		# The test is a bit hacky, but it avoids implementing another
		# mechanism.
		printf "argsparse_parse_option was not ran yet.\n"
	fi

	if [[ $# -eq 0 ]]
	then
		options=( "${!__argsparse_options_descriptions[@]}" )
	else
		options=( "$@" )
	fi
	for option in "${options[@]}"
	do
		argsparse_has_option_property "$option" hidden && continue
		printf "%- ${length}s\t: " "$option"
		if argsparse_is_option_set "$option"
		then
			printf "yes (%s" "${program_options[$option]}"
			if argsparse_has_option_property "$option" cumulative || \
				argsparse_has_option_property "$option" cumulativeset
			then
				array_name="$(argsparse_get_cumulative_array_name "$option")[@]"
				array=( "${!array_name}" )
				printf ' time(s):'
				for value in "${array[@]}"
				do
					printf ' %q' "$value"
				done
			fi
			printf ')\n'
		else
			printf '%s\n' no
		fi
	done
}

# "Main" stuff.


# We do define a default --help option.
argsparse_use_option "=help" "Show this help message"

##
# module
##

webminUpdateAdmin() {
	if [[ $ELX_WEBMIN_ADMIN ]]; then
		echo
		info "Your current webmin admin is '$ELX_WEBMIN_ADMIN'"
		read -p "  [?] Would you like to update the password? [ Y/n ]: " changePassword
		if [[ $changePassword = 'Y' ]]; then
			passwd $ELX_WEBMIN_ADMIN
			sleep 1s
			echo
			info "$ELX_WEBMIN_ADMIN password has been updated"
			echo
			return 0
		fi
	else
		webminCreateAdmin
	fi
}

webminCreateAdmin() {
	echo
	info "Configure a user with sudo level access for Webmin."
	echo
	if [[ $webminUname ]]; then
		useradd $webminUname
		if [[ $? = 0 ]]; then
			sleep 1s
			echo "  [?] Enter Webmin password below (input will be hidden): "
			echo
			passwd $webminUname
			s=" ALL=(ALL:ALL) ALL"
			echo $webminUname$s >> /etc/sudoers
			if [[ -e "$HOME/.elx" ]]; then
				sed -i -e 's#ELX_WEBMIN_ADMIN=.*#ELX_WEBMIN_ADMIN='$webminUname'#' $HOME/.elx
			else 
				touch $HOME/.elx
				echo "ELX_WEBMIN_ADMIN=$webminUname" >> $HOME/.elx
			fi
			echo
			info "You can now login with $webminUname"
			info "https://$url:10000/"
			echo
			return 0
		else
			unset webminUname
			warn "We couldn't create your user, please try again."
			webminCreateAdmin
		fi
	elif [[ -n $ELX_WEBMIN_ADMIN ]]; then
		if id -u "$ELX_WEBMIN_ADMIN" >/dev/null 2>&1; then
			webminUpdateAdmin
		else
			unset $ELX_WEBMIN_ADMIN
			webminCreateAdmin
		fi
	else 
		read -p "  [?] Enter Webmin username: " webminUname
		webminCreateAdmin
	fi
}

##
# module
##

ngxEnableSite() {

    [[ ! "$SELECTED_SITE" ]] &&
        ngxSelectSite "not_enabled"

    [[ ! -e "$NGINX_SITES_AVAILABLE/$SELECTED_SITE" ]] && 
        ngxError "  [!] Site does not appear to exist."
    [[ -e "$NGINX_SITES_ENABLED/$SELECTED_SITE" ]] &&
        ngxError "  [!] Site appears to already be enabled"

    ln -sf "$NGINX_SITES_AVAILABLE/$SELECTED_SITE" -T "$NGINX_SITES_ENABLED/$SELECTED_SITE"
    ngxReload

}

ngxDisableSite() {

    [[ ! "$SELECTED_SITE" ]] &&
        ngxSelectSite "is_enabled"

    [[ ! -e "$NGINX_SITES_AVAILABLE/$SELECTED_SITE" ]] &&
        ngxError "  [!] Site does not appear to be \'available\'. - Not Removing"
    [[ ! -e "$NGINX_SITES_ENABLED/$SELECTED_SITE" ]] &&
        ngxError "  [!] Site does not appear to be enabled."

    rm -f "$NGINX_SITES_ENABLED/$SELECTED_SITE"
    ngxReload

}

ngxListSites() {
    info "Available sites:"
    ngxSites "available"
    echo
    info "Enabled sites:"
    ngxSites "enabled"
    echo
}

ngxSelectSite() {

    sites_avail=($NGINX_SITES_AVAILABLE/*)
    sa="${sites_avail[@]##*/}"
    sites_en=($NGINX_SITES_ENABLED/*)
    se="${sites_en[@]##*/}"

    case "$1" in
        not_enabled) sites=$(comm -13 <(printf "%s\n" $se) <(printf "%s\n" $sa));;
        is_enabled) sites=$(comm -12 <(printf "%s\n" $se) <(printf "%s\n" $sa));;
    esac

    ngxPrompt "$sites"

}

ngxPrompt() {

    sites=($1)
    i=0

    echo "  [?] Please select a website:"
    for site in ${sites[@]}; do
        echo -e "$i:\t${sites[$i]}"
        ((i++))
    done
    if [[ i=0 ]]; then
        warn "No websites available"
    else
        read -p "  [?] Enter number selection: " i
        SELECTED_SITE="${sites[$i]}"
    fi
    echo
}

ngxSites() {

    case "$1" in
        available) dir="$NGINX_SITES_AVAILABLE";;
        enabled) dir="$NGINX_SITES_ENABLED";;
    esac

    for file in $dir/*; do
        if [[ $1 = "available" ]]; then
            echo -e "\e[2m\t${file#*$dir/}\e[0m"
        else
            echo -e "\e[1m\t${file#*$dir/}\e[0m"
        fi
    done

}

ngxReload() {

    #read -p "Would you like to reload the Nginx configuration now? (Y/n) " reload
    #[[ "$reload" != "n" && "$reload" != "N" ]] && invoke-rc.d nginx reload
    invoke-rc.d nginx reload
    echo
}

ngxError() {

    echo -e "\e[1m$1\e[0m"
    [[ "$2" ]] && ngx_help
    echo

}

ngxHelp() {

    echo "Usage: ${0##*/} [options]"
    echo "Options:"
    echo -e "\t<-e|--enable> <site>\tEnable site"
    echo -e "\t<-d|--disable> <site>\tDisable site"
    echo -e "\t<-l|--list>\t\tList sites"
    echo -e "\t<-h|--help>\t\tDisplay help"
    echo -e "\n\tIf <site> is left out a selection of options will be presented."
    echo -e "\tIt is assumed you are using the default sites-enabled and"
    echo -e "\tsites-disabled located at $NGINX_CONF_DIR."

}

nginxModsite() {

    case "$1" in
        -e|--enable)    ngxEnableSite;;
        -d|--disable)   ngxDisableSite;;
        -l|--list)  ngxListSite;;
        -h|--help)  ngxHelp;;
        *)      ngxError "No Options Selected" 1; ngxHelp;;
    esac
    
}


##
# module
##

apacheUpdateMaxClients() {
	info "We are going to restart Apache2 and update for the most optimal settings" 
	read -p "  [?] Restart Apache now [ Y/n ]: " doNow
	if [[ $doNow = "Y" ]]; then
		echo
		APACHE="apache2"
		APACHEMEM=$(ps -aylC $APACHE |grep "$APACHE" |awk '{print $8'} |sort -n |tail -n 1)
		APACHEMEM=$(expr $APACHEMEM / 1024)
		SQLMEM=$(ps -aylC mysqld |grep "mysqld" |awk '{print $8'} |sort -n |tail -n 1)
		SQLMEM=$(expr $SQLMEM / 1024)
		info "Stopping $APACHE to calculate the amount of free memory"
		/etc/init.d/$APACHE stop &> /dev/null
		TOTALFREEMEM=$(free -m |head -n 2 |tail -n 1 |awk '{free=($4); print free}')
		TOTALMEM=$(free -m |head -n 2 |tail -n 1 |awk '{total=($2); print total}')
		SWAP=$(free -m |head -n 4 |tail -n 1 |awk '{swap=($3); print swap}')
		MAXCLIENTS=$(expr $TOTALFREEMEM / $APACHEMEM)
		MINSPARESERVERS=$(expr $MAXCLIENTS / 4)
		MAXSPARESERVERS=$(expr $MAXCLIENTS / 2)
		info "Starting $APACHE again"
		/etc/init.d/$APACHE start &> /dev/null
		info "Total memory $TOTALMEM"
		info "Free memory $TOTALFREEMEM"
		info "Amount of virtual memory being used $SWAP"
		info "Largest Apache Thread size $APACHEMEM"
		info "Amount of memory taking up by MySQL $SQLMEM"
		if [[ SWAP > TOTALMEM ]]; then
		      ERR="Virtual memory is too high"
			  warn "$ERR"
		else
		      ERR="Virtual memory is ok"
			  info "$ERR"
		fi
		echo
		info "Total Free Memory $TOTALFREEMEM"
		info "MaxClients should be around $MAXCLIENTS"
		info "MinSpareServers should be around $MINSPARESERVERS"
		info "MaxSpareServers should be around $MAXSPARESERVERS"
		echo
		return 0
	fi
}

##
# module
##

mysqlUpdateRootPassword() {

	if [[ -z $oldpass ]]; then
		echo 
		info "Updating ROOT MySQL password"
		info "If this is a new instance, use 'elastrix' (no quotes)"
	fi
	echo
	read -s -p "  [?] Please enter the current root password (input will be hidden): " oldpass
	echo
	mysqladmin -uroot -p$oldpass status
	if [[ $? != 0 ]]; then
		echo -e "  \e[31m\e[1m[!] Incorrect root password. If this is a new instance, use 'elastrix' (no quotes).\e[0m"
		return 1
	fi
	read -s -p "  [?] Please enter your new desired root password (input will be hidden): " newpass
	mysqladmin -u root -p$oldpass password $newpass
	if [[ $? = 0 ]]; then
		echo
		info "Your MySQL root password has been updated"
		echo
		return 0
	else
		echo
		warn "We couldn't update your password, are you sure it's correct?"
		info "If this is a new instance, use 'elastrix' as the password."
		echo
		return 1
	fi
}

##
# module
##

wordpressUpdateMysqlPassword() {
	echo
	info "Updating WordPress MySQL password"
	info "If this is a new instance, use 'elastrix' (no quotes)"
	echo 
	read -s -p "  [?] Please enter a new MySQL Password for the WordPress user (input will be hidden): " newpass

	echo
	info "Your MySQL root password is required to complete this update, please enter it below."

	mysql -u root -p -e "SET PASSWORD FOR 'wpuser'@'localhost' = PASSWORD('"$newpass"');FLUSH PRIVILEGES;"
	
	if [[ -e "/var/www/html/wordpress/wp-cli.local" ]]; then
		sed -i.bak -e 's/dbpass: .*/dbpass: '$newpass'/' /var/www/html/wordpress/wp-cli.local.yml
		info "wp-cli.local.yml was updated"
	else
		echo -e "  \e[31m\e[1m[!] Could not update /var/www/html/wordpress/wp-cli.local\e[0m"
	fi

	if [[ -e "/var/www/html/wordpress/wp-config.php" ]]; then
		sed -i "/DB_PASSWORD/s/'[^']*'/'$newpass'/2" /var/www/html/wordpress/wp-config.php
		info "wp-config.php was updated"
	else
		echo "  \e[31m\e[1m[!] Could not update /var/www/html/wordpress/wp-config.php does not exist\e[0m"
		echo
		exit 1
	fi

	echo
	info "Your MySQL 'wpuser' password has been updated."
	info "The wp-cli, and wp-config has also been updated."
	echo
	return 0
}

##
# module
##

ghostUpdateMysqlPassword() {
	read -s -p "  [?] Enter a new Ghost MySQL Password (input will be hidden): " newpass
	echo
	info "We will need your ROOT MySQL Password to complete the update."
	mysql -u root -p -e "SET PASSWORD FOR 'ghost'@'localhost' = PASSWORD('"$newpass"');FLUSH PRIVILEGES;"
	sed -i.bak -e 's/password: .*/password: '\'$newpass\','/' /var/www/html/ghost/config.js
	echo
	info "Restarting Ghost..."
	service ghost restart
	echo
	info "The MySQL password for user 'ghost' has been updated."
	info "$HOME/webroot/ghost/config.js was updated"
	echo
	return 0
}

ghostUpdateUrl() {
	info "Your public URL is http://$url"
	read -p "  [?] Would you like to use this as your Ghost URL? [ Y/n ]: " answer

	if [ -z $answer ]; then 
		answer="Y" 
	fi

	if [ $answer != "Y" ]; then
		echo
		info "Please enter your full URL with protocol i.e. http://myhost.com"
		read url
	else
		url="http://$url"
	fi

	echo
	read -p "  [?] Updating Ghost Config URL to $url ok? [ Y/n ]: " answer

	if [ -z $answer ]; then 
	        answer="Y" 
	fi

	if [ $answer == "Y" ]; then
		sed -i.bak -e 's#url: .*#url: '\'$url\','#' /var/www/html/ghost/config.js
		echo
		info "Ghost config URL updated, restarting Ghost now."
		service ghost restart
		sleep 1s
		return 0	
	fi
}

##
# module
##

getTurnserverUsername () {
	read -p "  [?] Please enter a username for your turnserver: " username
}

getTurnserverPassword () {
	read -s -p "  [?] Please enter a password for your turnserver (input will be hidden): " password
}
kurentoUpdateTurnserver() {
	info "Updating Turnserver configuration"
	port=3478
	echo
	info "Your public hostname is $url"
	info "Your public IP is $ip"
	read -p "  [?] Would you like to use this for your turnserver configuration? [ Y/n ]: " answer

	if [ -z $answer ]; then
		answer="Y"
	fi

	if [ $answer != "Y" ]; then
		echo
		info "Please enter your public hostname i.e. myhost.com"
		read url
	fi

	echo
	read -p "  [?] Updating Turnserver url to $url ok? [ Y/n ]: " answer

	if [ -z $answer ]; then
		answer="Y"
	fi

	if [ $answer == "Y" ]; then	
		
		if [[ -f "/etc/turnserver.conf" ]]; then
			mv /etc/turnserver.conf /etc/turnserver.conf.bak
			touch /etc/turnserver.conf
		else
			touch /etc/turnserver.conf
		fi

		echo "listening-device=eth0" > /etc/turnserver.conf
		echo "listening-ip=$url" >> /etc/turnserver.conf
		echo "listening-port=$port" >> /etc/turnserver.conf
		echo "userdb=turnuserdb.conf" >> /etc/turnserver.conf
		echo "relay-device=eth0" >> /etc/turnserver.conf
		echo "realm=$url" >> /etc/turnserver.conf
		echo "lt-cred-mech" >> /etc/turnserver.conf
		echo "log-file=/var/log/turnserver.log" >> /etc/turnserver.conf
		echo
		info "Updated /etc/turnserver.conf:"
		cat /etc/turnserver.conf
		echo
	else
		warn "Not making any updates to turnserver.conf"
	fi

	info "Next we are creating a username and password for the Turn Server."
	info "The Turn Server handles user signaling for WebRTC peers and NAT traversal."

	getTurnserverUsername

	if [ -z $username ]; then
		getTurnserverUsername
	fi

	getTurnserverPassword

	echo

	if [ -z $password ]; then
		getTurnserverPassword
	fi

	info "Updating /etc/turnuserdb.conf"
	echo "$username:$password" > /etc/turnuserdb.conf

	echo
	info "Updating /etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini"
	sed -i.bak -e 's#turnURL=.*#turnURL='$username':'$password'@'$ip':'$port'#' /etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini

	info "Restarting Kurento..."
	service kurento-media-server-6.0 restart
	sleep 1s
	service turnserver restart
	sleep 1s
	echo
	info "Turnserver configuration complete."
	echo
	return 0
}

##
# module
##

monitUpdateWebServer() {
	echo
	info "Configure Monit Web Server Settings."
	echo

	read -p "  [?] Monit Web Server Port (2812): " monitHttpPort
	read -p "  [?] Enter Username: " monitHttpUser
	read -s -p "  [?] Enter Password (hidden): " monitHttpPass

	if [[ -z $monitHttpPort ]]; then
		monitHttpPort=2812
	fi

	echo "set httpd port ${monitHttpPort} and" > /etc/monit/conf.d/monit-http.conf
	echo "    allow ${monitHttpUser}:${monitHttpPass}" >> /etc/monit/conf.d/monit-http.conf

	service monit restart
	echo
	info "Monit web server running at http://${url}:${monitHttpPort}"
	echo
	return 0
}

monitDisableWebServer() {
	echo
	info "Configure Monit Web Server Settings."
	echo
	if [ -e '/etc/monit/conf.d/monit-http.conf' ]; then
    	rm -fR /etc/monit/conf.d/monit-http.conf
    fi
    service monit restart
	echo
	info "Monit web server disabled"
	echo
	return 0
}

##
# module
##

sslCreateRootCa() {
	# make directories to work from
	mkdir -p ~/certs/{server,client,ca,tmp}

	# Create your very own Root Certificate Authority
	openssl genrsa \
	  -out ~/certs/ca/my-root-ca.key.pem \
	  2048

	# Self-sign your Root Certificate Authority
	# Since this is private, the details can be as bogus as you like
	openssl req \
	  -x509 \
	  -new \
	  -sha256 \
	  -nodes \
	  -key ~/certs/ca/my-root-ca.key.pem \
	  -days 3652 \
	  -out ~/certs/ca/my-root-ca.crt.pem \
	  -subj "/C=US/ST=New York/L=Provo/O=Elastrix Signing Authority Inc/CN=${url}"

	# NOTE
	# -nodes means "no-des" which means "no passphrase"
	# -days 3652 means that this example will break about 10 years from now
	return 0
}

sslCreateServerCerts() {
	info "Your public DNS is $url"
	read -p "  [?] Would you like to use this as the SSL Common Name (CN)? [ Y/n ]: " answer

	if [ -z $answer ]; then 
		answer="Y" 
	fi

	if [ $answer != "Y" ]; then
		echo
		info "Please enter your domain name i.e. example.com"
		read url
	fi

	echo

	read -p "  [?] Creating certs for $url ok? [ Y/n ]: " answer

	if [ -z $answer ]; then 
	        answer="Y" 
	fi

	if [ $answer == "Y" ]; then
		
		sslCreateRootCa $url

		# make directories to work from
		mkdir -p ~/certs/{server,client,ca,tmp}

		# Create Certificate for this domain,
		openssl genrsa \
		  -out ~/certs/server/my-server.key.pem \
		  2048

		# Create the CSR
		openssl req -new \
		  -key ~/certs/server/my-server.key.pem \
		  -out ~/certs/tmp/my-server.csr.pem \
		  -subj "/C=US/ST=New York/L=Provo/O=Elastrix Service/CN=${url}"

		echo

		# sign the certs
		sslSignCsr

		info "Certificate generation complete!"
		info "Certificates available in ~/certs"
		echo
		return 0	
	else
		info "OK Cancelling, Goodbye!"
		echo
		return 0
	fi
}

sslSignCsr() {

	read -p "  [?] Do you have a serial file i.e. ~/my-root-ca.srl [ y/N ]: " answer

	if [[ $answer == "N" ]]; then
		sslCa="createserial"
	elif [ -z $answer ]; then
		sslCa="createserial"
	else
		read -p "  [?] Please enter the full path the your serial file i.e. /home/ubuntu/my-root-ca.srl: " sslSrlPath
		if [ -e "${sslSrlPath}" ]; then
			sslCa="serial ${$sslSrlPath}"
		else
			warn "${sslSrlPath} was not found, cancelling."
			echo
			exit 0
		fi
	fi

	# Sign the request from Device with your Root CA
	openssl x509 \
	  -req -in ~/certs/tmp/my-server.csr.pem \
	  -sha256 \
	  -CA ~/certs/ca/my-root-ca.crt.pem \
	  -CAkey ~/certs/ca/my-root-ca.key.pem \
	  -CA$sslCa \
	  -out ~/certs/server/my-server.crt.pem \
	  -days 1095

	# If you already have a serial file, you would use that (in place of CAcreateserial)
	# -CAserial certs/ca/my-root-ca.srl
	return 0
}

##
# module
##

parseUpdateDashboardAuth() {
	echo
	info "Configure Parse Dashboard Basic Authentication."
	warn "Warning, the Parse Server will be restarted!"
	echo

	read -p "  [?] Enter username: " parseUser
	read -s -p "  [?] Enter password (input hidden): " parsePass
	
	if [[ $PARSE_DASH_USER ]]; then
		sed -i -e 's#export PARSE_DASH_USER=.*#export PARSE_DASH_USER='$parseUser'#' $HOME/.elx
	else
		echo -e "\n\nexport PARSE_DASH_USER=${parseUser}" >> $HOME/.elx
	fi

	if [[ $PARSE_DASH_PASS ]]; then
		sed -i -e 's#export PARSE_DASH_PASS=.*#export PARSE_DASH_PASS='$parsePass'#' $HOME/.elx
	else
		echo -e "\nexport PARSE_DASH_PASS=${parsePass}" >> $HOME/.elx
	fi

	echo
	info "Authentication Updated, Restarting Parse Server..."

	. $HOME/.elx
	service parse restart
	
	echo
	info "Authentication update is complete."
	info "Login to Parse Dashboard at https://$url/dashboard"
	info "Parse Server running at https://$url/parse"
	return 0
}

parseUpdateApp() {
	echo
	info "Configure Parse App Settings."
	warn "Warning, the Parse Server will be restarted!"
	echo

	if [[ $PARSE_APP_ID ]]; then
		info "Leave blank to keep existing value"
	fi

	if [[ $PARSE_APP_ID ]]; then
		read -p "  [?] App ID (${PARSE_APP_ID}): " parseAppId
		if [[ $parseAppId ]]; then
			sed -i -e 's#export PARSE_APP_ID=.*#export PARSE_APP_ID='$parseAppId'#' $HOME/.elx
		fi
	else
		read -p "  [?] App ID: " parseAppId
		echo -e "\n\nexport PARSE_APP_ID=${parseAppId}" >> $HOME/.elx
	fi

	if [[ $PARSE_APP_NAME ]]; then
		read -p "  [?] App Name (${PARSE_APP_NAME}): " parseAppName
		if [[ $parseAppName ]]; then
			sed -i -e 's#export PARSE_APP_NAME=.*#export PARSE_APP_NAME='$parseAppName'#' $HOME/.elx
		fi
	else
		read -p "  [?] App Name: " parseAppName
		echo -e "\nexport PARSE_APP_NAME=${parseAppName}" >> $HOME/.elx
	fi

	if [[ $PARSE_MASTER_KEY ]]; then
		read -p "  [?] Master Key (${PARSE_MASTER_KEY}): " parseMasterKey
		if [[ $parseMasterKey ]]; then
			sed -i -e 's#export PARSE_MASTER_KEY=.*#export PARSE_MASTER_KEY='$parseAppName'#' $HOME/.elx
		fi
	else
		read -p "  [?] Master Key: " parseMasterKey
		echo -e "\nexport PARSE_MASTER_KEY=${parseMasterKey}" >> $HOME/.elx
	fi

	if [[ $PARSE_FILE_KEY ]]; then
		read -p "  [?] File Key (Optional) (${PARSE_FILE_KEY}): " parseFileKey
		if [[ $parseFileKey ]]; then
			sed -i -e 's#export PARSE_FILE_KEY=.*#export PARSE_FILE_KEY='$parseFileKey'#' $HOME/.elx
		fi
	else
		read -p "  [?] File Key (Optional): " parseFileKey
		echo -e "\nexport PARSE_FILE_KEY=${parseFileKey}" >> $HOME/.elx
	fi

	if [[ $PARSE_APP_PRODUCTION ]]; then
		read -p "  [?] Production? [true/false] (${PARSE_APP_PRODUCTION}): " parseProduction
		if [[ $parseProduction ]]; then
			if [[ $parseProduction = 'true' || $parseProduction = 'false' ]]; then
				sed -i -e 's#export PARSE_APP_PRODUCTION=.*#export PARSE_APP_PRODUCTION='$parseProduction'#' $HOME/.elx
			else 
				warn "Invalid value for production. Accepted values include true or false"
				return 0
			fi
		fi
	else
		read -p "  [?] Production? [true/false]: " parseProduction
		if [[ $parseProduction = 'true' || $parseProduction = 'false' ]]; then
			echo -e "\nexport PARSE_APP_PRODUCTION=${parseProduction}" >> $HOME/.elx
		else 
			warn "Invalid value for production. Accepted values include true or false"
			return 0
		fi
	fi

	. $HOME/.elx

	echo
	service parse restart

	echo
	info "Parse Server configuration update is complete."
	info "Login to Parse Dashboard at https://$url/dashboard"
	info "Parse Server running at https://$url/parse"
	return 0
}
parseUpdateDb() {
	echo
	info "Configure Parse Database Settings."
	warn "Warning, the Parse Server will be restarted!"
	echo

	if [[ $PARSE_DATABASE_URI ]]; then
		read -p "  [?] Database URI (${PARSE_DATABASE_URI}): " parseDbUri
		if [[ $parseDbUri ]]; then
			sed -i -e 's#export PARSE_DATABASE_URI=.*#export PARSE_DATABASE_URI='$parseFileKey'#' $HOME/.elx
		fi
	else
		read -p "  [?] Database URI (mongodb://localhost:27017/dev): " parseDbUri
		if [[ $parseDbUri ]]; then
			echo -e "\nexport PARSE_DATABASE_URI=${parseDbUri}" >> $HOME/.elx
		fi
	fi
	
	. $HOME/.elx

	echo
	service parse restart

	echo
	info "Parse Server database configuration update is complete."
	info "Login to Parse Dashboard at https://$url/dashboard"
	info "Parse Server running at https://$url/parse"
	return 0
}
parseUpdateSrv() {
	echo
	info "Configure Parse Server Settings."
	warn "Warning, the Parse Server will be restarted!"
	echo

	if [[ $PARSE_SERVER_URL ]]; then
		info "Leave blank to keep existing value"
	fi

	if [[ $PARSE_CLOUD_CODE_MAIN ]]; then
		read -p "  [?] Cloud Code Location (${PARSE_CLOUD_CODE_MAIN}): " parseCloudCodeMain
		if [[ $parseCloudCodeMain ]]; then
			sed -i -e 's#export PARSE_CLOUD_CODE_MAIN=.*#export PARSE_CLOUD_CODE_MAIN='$parseCloudCodeMain'#' $HOME/.elx
		fi
	else
		read -p "  [?] Cloud Code Location (/etc/parse/cloud/main.js): " parseCloudCodeMain
		if [[ $parseCloudCodeMain ]]; then
			echo -e "\nexport PARSE_CLOUD_CODE_MAIN=${parseCloudCodeMain}" >> $HOME/.elx
		fi
	fi
	
	if [[ $PARSE_ALLOW_INSECURE_HTTP ]]; then
		read -p "  [?] Allow Insecure HTTP access to Dashboard? [y/N]: " parseAllowHttp
		if [[ $parseAllowHttp = 'y' || $parseAllowHttp = 'Y' ]]; then
			parseAllowHttpValue=1
		else
			parseAllowHttpValue=0
		fi
		sed -i -e 's#export PARSE_ALLOW_INSECURE_HTTP=.*#export PARSE_ALLOW_INSECURE_HTTP='$parseAllowHttpValue'#' $HOME/.elx
	else
		read -p "  [?] Allow Insecure HTTP access to Dashboard? [y/N]: " parseAllowHttp
		if [[ $parseAllowHttp = 'y' || $parseAllowHttp = 'Y' ]]; then
			parseAllowHttpValue=1
		else
			parseAllowHttpValue=0
		fi
		echo -e "\nexport PARSE_ALLOW_INSECURE_HTTP=${parseAllowHttpValue}" >> $HOME/.elx
	fi

	if [[ $PARSE_SERVER_URL ]]; then
		read -p "  [?] Server URL (${PARSE_SERVER_URL}): " parseServerURL
		if [[ $parseServerURL ]]; then
			sed -i -e 's#export PARSE_SERVER_URL=.*#export PARSE_SERVER_URL='$parseServerURL'#' $HOME/.elx
		fi
	else
		read -p "  [?] Server URL (http://${url}/parse): " parseServerURL
		if [[ $parseServerURL ]]; then
			echo -e "\nexport PARSE_SERVER_URL=${parseServerURL}" >> $HOME/.elx
		fi
	fi

	. $HOME/.elx

	echo
	service parse restart

	echo
	info "Parse Server configuration update is complete."
	info "Login to Parse Dashboard at https://$url/dashboard"
	info "Parse Server running at http://$url/parse"
	return 0
}

##
# module
##

updateElxSetupConfig() {
	if [[ -e "$HOME/.elx" ]]; then
		
		if [[ -n $ELX_SETUP ]]; then
			sed -i -e 's#ELX_SETUP=.*#ELX_SETUP=1#' $HOME/.elx
		else 
			echo "ELX_SETUP=1" >> ~/.elx
		fi

		if [[ -n $ELX_ENV ]]; then
			sed -i -e 's#ELX_ENV=.*#ELX_ENV='$1'#' $HOME/.elx
		else
			echo "ELX_ENV=$1" >> ~/.elx
		fi

	else 
		touch $HOME/.elx
		updateElxSetupConfig $1
	fi
}

setupLAMP() {

	echo
	info "This setup will:"
	echo "     - create a user you can login to Webmin with."
	echo "     - update your root MySQL password."
	echo "     - update Apache's MaxClient directive for optimal settings"

	webminCreateAdmin
	sleep 1s

	if [[ $ELX_SETUP ]]; then
		echo
		read -p "  [?] MySQL already configured, would you like to update the root password? [ Y/n ]: " update
	fi
	
	if [[ $update = "Y" ]] || [ -z $update ]; then
		mysqlUpdateRootPassword
	fi

	sleep 1s

	if [[ $ELX_SETUP ]]; then
		echo
		read -p "  [?] Re-run Apache optimizations? [ Y/n ]: " update
	fi
	
	if [[ $update = "Y" ]] || [ -z $update ]; then
		apacheUpdateMaxClients
	fi
	
	sleep 1s
	updateElxSetupConfig "LAMP"

	info "LAMP Setup complete."
	info "You can access Webmin at $url:10000"
	echo ""
}

setupWordpressApache() {

	setupLAMP
	sleep 1s
	wordpressUpdateMysqlPassword
	sleep 1s

	a2dissite elastrix
	a2ensite wordpress
	service apache2 reload

	info "Wordpress LAMP Setup Complete."
	info "You can access Webmin at $url:10000"
	echo

}

setupWordpressNginx() {
	
	info "This setup will:"
	echo "     - create a user you can login to Webmin with."
	echo "     - update your root MySQL password."
	echo "     - update WordPress MySQL password."

	webminCreateAdmin
	sleep 1s

	if [[ $ELX_SETUP ]]; then
		echo
		read -p "  [?] MySQL already configured, would you like to update the root password? [ Y/n ]: " update
	fi
	
	if [[ $update = "Y" ]] || [ -z $update ]; then
		mysqlUpdateRootPassword
	fi

	wordpressUpdateMysqlPassword
	sleep 1s

	echo
	info "Disabling Elastrix site..."
	
	SELECTED_SITE="elastrix"
	ngxDisableSite
	sleep 1s
	
	echo
	info "Enabling Ghost NGINX site..."
	
	SELECTED_SITE="wordpress"
	ngxEnableSite
	sleep 1s

	updateElxSetupConfig "WordPressNginx"

	info "WordPress NGINX Setup complete."
	info "You can access Webmin at $url:10000"
	echo
}

setupGhostNginx() {
	
	echo 
	info "This setup will:"
	echo "      - create a user you can login to Webmin with."
	echo "      - update your root MySQL password."
	echo "      - update your Ghost MySQL password."
	echo "      - update your Ghost public URL."
	echo "      - enable your Ghost NGINX Website."
	echo 

	webminCreateAdmin
	sleep 1s
	if [[ $ELX_SETUP ]]; then
		echo
		read -p "  [?] MySQL already configured, would you like to update the root password? [ Y/n ]: " update
	fi
	
	if [[ $update = "Y" ]] || [ -z $update ]; then
		mysqlUpdateRootPassword
	fi
	sleep 1s
	
	if [[ $ELX_SETUP ]]; then
		echo
		read -p "  [?] Ghost DB already configured, would you like to update configuration? [ Y/n ]: " update
	fi
	
	if [[ $update = "Y" ]] || [ -z $update ]; then
		ghostUpdateMysqlPassword
	fi
	
	sleep 1s

	if [[ $ELX_SETUP ]]; then
		echo
		read -p "  [?] Ghost URL already configured, would you like to change it? [ Y/n ]: " update
	fi
	
	if [[ $update = "Y" ]] || [ -z $update ]; then
		ghostUpdateUrl
	fi

	echo
	info "Disabling Elastrix site..."
	
	SELECTED_SITE="elastrix"
	ngxDisableSite
	sleep 1s
	
	echo
	info "Enabling Ghost NGINX site..."
	
	SELECTED_SITE="default"
	ngxEnableSite
	sleep 1s
	
	info "Starting monitor service to keep things up..."
	monit -d 60 -c /etc/monit/monitrc
	
	updateElxSetupConfig "GhostNginx"

	echo
	info "Setup complete."
	info "Visit $url/ghost to access your Ghost site admin."
	echo
	exit 0
}

setupElastrixMediaServer() {

	echo 
	info "This setup will:"
	echo "      - create a user you can login to Webmin with."
	echo "      - update your root MySQL password."
	echo "      - update your turn server configuration."
	echo "      - update Kurento configuration"
	echo "      - update NGINX enabled sites"
	echo 

	webminCreateAdmin
	
	sleep 1s
	
	if [[ $ELX_SETUP ]]; then
		echo
		read -p "  [?] MySQL already configured, would you like to update the root password? [ Y/n ]: " update
	fi
	
	if [[ $update = "Y" ]] || [ -z $update ]; then
		mysqlUpdateRootPassword
	fi

	sleep 1s

	if [[ $ELX_SETUP ]]; then
		echo
		read -p "  [?] Turn Server already configured, would you like to re-configure? [ Y/n ]: " update
	fi
	
	if [[ $update = "Y" ]] || [ -z $update ]; then
		kurentoUpdateTurnserver
	fi

	info "Disabling Elastrix site..."
	
	SELECTED_SITE="elastrix"
	ngxDisableSite
	sleep 1s
	
	echo
	info "Enabling Kurento NGINX site..."
	
	SELECTED_SITE="default"
	ngxEnableSite
	sleep 1s

	updateElxSetupConfig "EMS"

	echo
	info "Setup complete."
	info "Visit $url to access the demo website."
	echo
	exit 0
}

setupParse() {
	echo 
	info "This setup will:"
	echo "      - create a user you can login to Webmin with"
	echo "      - update Parse Dashboard authentication"
	echo "      - Update Parse App Settings"
	echo "      - update Monit Web Server"
	echo 

	webminCreateAdmin
	sleep 1s
	monitUpdateWebServer
	sleep 1s
	parseUpdateDashboardAuth
	sleep 1s
	parseUpdateApp
	sleep 1s
	updateElxSetupConfig "Parse"

	echo
	info "Parse Setup complete."
	echo
	exit 0
}

##
# module
##

##
# initialize the interface
##

ELX_VERSION="1.3.4"

## Render the header and check the platform
header
checkPlatform
init

## Set the default color for
echo -e "\e[39m"
argsparse_use_option setup "Setup this app" short:s
argsparse_use_option nginx "Work with NGINX" short:x
argsparse_use_option ghost "Configure Ghost" short:g value
argsparse_use_option wp "Configure WordPress" short:w value
argsparse_use_option apache "Work with Apache" short:a value
argsparse_use_option ems "Configure Media Server" short:e
argsparse_use_option mysql "Configure MySQL" short:m
argsparse_use_option webmin "Configure Webmin user" short:u
argsparse_use_option parse "Configure Parse Server" short:p
argsparse_use_option monit "Configure Monit" short:n
argsparse_use_option version "View Elastrix Version" short:v
argsparse_use_option certs "Generate SSL certificates" short:c


# You can define your own usage function
usage() {
	#argsparse_usage
	echo
	echo -e "  \e[1m\e[4mApp Functions\e[0m"
	echo
	echo "  -h |  --help       Display this message"
	echo "  -s |  --setup      Run app setup"
	
	## Webmin functions
	if [ -e "/etc/init.d/webmin" ]; then
		echo "  -u |  --webmin     Configure Webmin user"
	fi

	## Ghost functions
	if [ -e "/var/www/html/ghost" ]; then
		echo
		echo "  -g |  --ghost db   Update Ghost database configuration"
		echo "        --ghost url  Update Ghost public URL"
	fi

	## Wordpress functions
	if [ -e "/var/www/html/wordpress" ]; then
		echo
		echo "  -w |  --wp db      Configure WordPress"
	fi

	## Kurento options
	if [ -e "/etc/turnuserdb.conf" ]; then
		echo
		echo -e "  \e[1m\e[4mElastrix Media Server\e[0m"
		echo
		echo "  -e |  --ems        Configure Elastrix Media Server"
	fi

	if [ -e "/etc/init.d/mysql" ]; then
		echo
		echo -e "  \e[1m\e[4mMySQL Functions\e[0m"
		echo
		echo "  -m |  --mysql       Configure MySQL root password"
	fi

	## Apache functions
	if [ -e "/etc/init.d/apache2" ]; then
		echo
		echo -e "  \e[1m\e[4mApache Functions\e[0m"
		echo
		echo "  -a |  --apache     Optimize Apache"
	fi

	## NGINX functions
	if hash nginx 2>/dev/null; then
		echo
		echo -e "  \e[1m\e[4mNGINX Functions\e[0m"
		echo
		echo "  -x |  --nginx enable  [name]    Enable [name] NGINX site"
		echo "        --nginx disable [name]    Disable [name] NGINX site"
		echo "        --nginx list              List NGINX sites"
		echo
	fi

	## Parse Server functions
	if [ -e "/etc/init/parse.conf" ]; then
		echo
		echo "  -p |  --parse auth 	Update Parse Dashboard Basic Authentication"
		echo "        --parse app 	Update Parse App Configuration"
		echo "        --parse db 	Update Parse MongoDB Configuration"
		echo "        --parse srv 	Update Parse Server Configuration"
	fi

	## Monit functions
	if [ -e "/etc/monit/monitrc" ]; then
		echo
		echo "  -n |  --monit web 	Update Monit Web Server"
		echo "        --monit kill 	Disable Monit Web Server"
	fi

	## SSL functions
	echo
	echo "  -c |  --certs gen 	Generate self-sligned SSL certificates in ~/certs."
	echo
	
	exit 0
}

argsparse_parse_options "$@"

##
# Arguments
##

if argsparse_is_option_set "setup"
	then
	setup
elif argsparse_is_option_set "nginx"
	then
	case "$2" in
		enable)
			SELECTED_SITE=$3
			ngxEnableSite
			;;

		disable)
			SELECTED_SITE=$3
			ngxDisableSite
			;;

		list)
			ngxListSites
			;;
		*)
			ngxListSites
			;;
		esac
elif argsparse_is_option_set "apache"
	then
	apacheUpdateMaxClients
elif argsparse_is_option_set "ghost"
	then
	case "$2" in
		db)
			ghostUpdateUrl
			;;
		url)
			ghostUpdateMysqlPassword
			;;
		esac
elif argsparse_is_option_set "wp"
	then
	wordpressUpdateMysqlPassword
elif argsparse_is_option_set "ems"
	then
	kurentoUpdateTurnserver
elif argsparse_is_option_set "mysql"
	then
	mysqlUpdateRootPassword
elif argsparse_is_option_set "webmin"
	then
	webminCreateAdmin
elif argsparse_is_option_set "parse"
	then
	case "$2" in
		auth)
			parseUpdateDashboardAuth
			;;
		app)
			parseUpdateApp
			;;
		db)
			parseUpdateDb
			;;
		srv)
			parseUpdateSrv
			;;
		esac
elif argsparse_is_option_set "monit"
	then
	case "$2" in
		web)
			monitUpdateWebServer
			;;
		kill)
			monitDisableWebServer
			;;
		esac
elif argsparse_is_option_set "version"
	then
	echo
	info "Elastrix CLI v${ELX_VERSION}"
	echo
elif argsparse_is_option_set "certs"
	then
	sslCreateServerCerts
else
	i=1
	for param in "${program_params[@]}"
	do
		printf "\e[1m\e[31m[!] Unrecognized option %s\n" $((i++)) "$param not recognized."
		echo -e "\e[39m[i] Try $me -h"
		echo
	done
	exit 1
fi